[단어]
global position (절대 좌표)
local position (지역 좌표) - 상속

hierarchy 계급
component 구성요소
Prefab 조립부품
material 재료, 재질


[기본조작]######################################
[Scene 방향조절] 
우click + a,s,d,f 

[검색] 
ctrl + k 

[잘못추가된 object 찾는 법] 
우클릭 + Find References In Scene

[console view : ctrl + shift + c]
Debug.Log("" + 변수);


Debug.Log("consol창에서 출력할 내용")   //출력 함수
################################################





[배열과 리스트]
string[] monster1 = {"쥐", "토끼", "사슴"}

string[] monster2 = new string[3]
monster2[0] = 늑대
monster2[1] = 멧돼지
monster2[2] = 곰

List<string> items = new List<string>();   // <>안에는 data type이 들어간다
items.Add("생명물약");
items.Add("정신물약");
items.RemoveAt(0);	//제거 또는 사용로직


[반복문]
while(health>0) {health--;  if(health==10) {break;} }

for (int n=0; n< monster1.Length-1; n++){}

foreach(string monster in monster1){Debug.Log("이 지역의 몹 : ") + monster}


[함수(method)]
int Heal(int currentHealth)	//반환이 없을 경우 void
{
currentHealth += 10;
Debug.Log("힐을 받았습니다.") + currentHealth
return currentHealth;
}



[클래스와 상속]
class Name1
{전역변수
void Start{}
void Update{}
void Name2{지역변수}
}

script1
class Player : MonoBehaviour //MonoBehaviour은 Unity Class 
{
protected int id;
protected string name;
protected string class;
}

script2
Player p = new Player();
p. //id, name, class 가 뜸  






[Unity Method 순서]

//최초 한번만 실행, 초기화영역
void Awake(){}	
void Start(){}

void OnEnable(Debug.Log("로그인"){}		//object 활성화시

//프레임
void FixedUpdate(){}	//물리연산, 고정된 주기로 CPU사용
void Update(){}		//게임로직, 환경에 따라 실행주기가 달라짐
void LateUpdate(){}		//로직의 후처리, 카메라 등

void OnDisable(){Debug.Log("로그아웃")}	//object 비활성화시

//해체, 삭제
void OnDestroy(){Debug.Log("(이 script가 적용된 object 삭제시) 해제되었습니다.") }





[Component]
Rigidbody(중력)        // mass 무게, 떨어지는 속도는 똑같으나 무거울수록 충돌 효과가 큼
	                // isKinematic 중력 효과 없이 script 연산만 사용, 함정, 장애물 만들때 사용	
Collider(충돌 영역)     // isTrigger 충돌 효과 없이 충돌 영역만 인식, radius 반지름,  
Material(재질)	    // Albedo : drag로 texture 이미지 삽입 가능, smoothness : 빛반사량, Tiling : 반복, Emission : (비물리적) 재질느낌의 발광,   

create - physics Material(탄성력)  //Bounsiness : 탄성력, Bounce Combine : 다음 탄성력 계산, maxium시 갈수록 탄성, Dynamic/Static Friction:마찰력, Friction Combine : 다음 마찰력 계산



[함수의 종류]
[0. 기본 문법]
Time.deltaTime;  	   // 이전 프레임까지 완료된 시간, 1프레임에 사용된 시간), 구형 : 1프레임 10fps 업데이트 10번 / 신형 : 1프레임 100fps 업데이트 100번
		   //transform 이동은 항상 Time.deltaTime 필수
ForceMode.Impulse;  //ForceMode : 힘을 주는 방식(가속,무게)
ForceMode.
ForceMode.
ForceMode.

GetButtonDown()	//눌렀을때
GetButton()
GetButtonUp()	//뗐을 때


[1. Vector3 : 이동함수]
Vector3 t = new Vector3(8, 1.5f, 0);
Vector3 v = Vector3.zero;

transform.position = Vector3._____(현재위치, 목표위치, 속도); 
transform.position = Vector3.MoveTowards(vec1, vec2, 속도(비례 증가)); //일정속도 이동
transform.position = Vector3.SmoothDamp(transform.position, t, ref v(참조접근,실시간으로 바뀌는 값 적용), 1f(반비례 증가)); //부드럽게 도착
transform.position = Vector3.Lerp(transform.position, t, 1f(비례 증가,최댓값1)); // 선형 보간
transform.position = Vector3.SLerp(transform.position, t, 1f(비례 증가,최댓값1)); //구면 선형 보간 : 포물선이동

[Vector3(x, y, z) - ]
Vector3.forward    Vector3(0,0,1)
Vector3.back        Vector3(0,0,-1)
Vector3.right        Vector3(1,0,0)
Vector3.left          Vector3(-1,0,0)
Vector3.up           Vector3(0,1,0)
Vector3.down       Vector3(0,-1,0)



[2. Rigidbody]
void Start
{
Rigidbody r = GetComponent<Rigidbody>();     // <>안에는 data type이 들어간다

r.velocity = Vector3.right();			 //velocity 현재 이동속도
r.velocity = new Vector3(x, y, z);
r.AddForce(Vector3.up * 5, ForceMode.Impulse); //AddForce : 지정방향으로 가속 증가
r.AddTorque(Vecor3.back); 			 //이동 방향을 축으로 회전력이 생김					
}

void FixedUpdate()				 //rigidbody는 항상 FixedUpdate 권장
{
r.velocity = new Vector3(x, y, z); 		 //Update함수들에서 작성시 해당 방향으로 무한 증가, 로켓 발사 가능

}

[3. Input. 키입력 함수]

Input.GetAxis("Horizontal") 	        -1.0f   ~   1.0f
Input.GetAxisRaw("Horizontal")      -1.0f,  0f,  1.0f

(예제1)
Vector3 vec = new Vector3(Input.GetAxisRaw("Horizontal"), 0, Input.GetAxisRaw("Vertical")); //키입력 방향으로 이동
r.AddForce(vec, ForceMode.Impulse) 			//이동함수 방향으로 물리력주기

(예제2)
float h = Input.GetAxisRaw("Horizontal")
float v = Input.GetAxisRaw("Vertical")
Vector3 vec = new Vector3(h, 0, v); 			//해당 입력 방향으로 이동
r.AddForce(new Vector3(h, 0, v), ForceMode.Impulse) 

[Collision 충돌 함수]
OnCollisionEnter/Stay/Exit   ///충돌하는 두 물체의 Collider component에 isTrigger 비활성화 (물리 충돌해야 하는 경우)
OnTriggerEnter/Stay/Exit    ///충돌하는 두 물체 중 한쪽 이상의 Collider component에 isTrigger 활성화 (물리충돌할 필요가 없는 경우)


(예제)
(색상, 재질변경)
MeshRenderer mesh; 	// object 재질 접근
Material mat;	  	 // object 재질
	
void Start()
{
mesh = GetComponent<MeshRenderer>();
mat = mesh.material;
}

void onCollisionEnter(Collision c)	//물리 충돌 시작될 때 호출
{
//mat.color = new Color(0, 0, 0)	//floor과 닿았으므로 미리 색상이 바뀌어 있다.

if(c.gameObject.name == "ObjectName")   //해당object와 충돌시 색상변경
  mat.color = new Color(0,0,0);
}

void onCollisionStay(Collision c){}	//물리 충돌 지속 중 호출

void onCollisionExit(Collision c)	//물리 충돌 끝났을 때 호출
{
if(c.gameObject.name == "ObjectName")  
  mat.color = new Color(1,1,1);

}


[4. OnTrigger : 물리적 충돌이 아닌 Colider 충돌]
OnCollisionEnter/Stay/Exit   ///충돌하는 두 물체의 Collider component에 isTrigger 비활성화 (물리 충돌해야 하는 경우)
OnTriggerEnter/Stay/Exit    ///충돌하는 두 물체 중 한쪽 이상의 Collider component에 isTrigger 활성화 (물리충돌할 필요가 없는 경우)


OnTriggerEnter(Colider c){}

OnTriggerStay(Colider c)	//Colider가 계속 충돌하고 있을때 호출
{
if(c.gameObject.name == "ObjectName")  
  r.AddForce(Vector3.up * 2, ForceMode.Impulse) //위로 붕 뜬다.
}

OnTriggerExit(Colider c){}

 

[5. Canvas ] 
screen : 씬의 카메라에 보이지는 않지만 실제 게임 화면 출력시 나타나는 창 

UI Text
Font : 무료폰트 외에는 라이센스 꼭 확인해야함
Line Spacing : 2     //행간 띄워쓰기
Horizontal/Vertical Overflow :  overflow로 설정시 글자 초과시에도 보임
 
UI Image
(준비 : 아무 Image 클릭 - Texture Type : Sprite (2D and UI) - apply 적용해야 image 삽입 가능)

Rect Transform
Anchor Presets 	//기준점 맞추기,  shift : 파란점, component에서 기준점,    shift + alt : component의 위치

Image
Source Image : 	  //Sprite (2D and UI)적용한 image를 drag해서 넣기
Image Type : 	  // Filed : image 2개 겹친 뒤 사용하면 쿨타임 효과
Preserve Aspect : 	  //비율 고정
Set Native Size :      //실제 크기로 조정

UI Button
Image Type : 	//sliced : 해당image의 모서리를 자르고 가운데만 채움
color Multiplier	//색 섞는 강도
FadeDuration :	//색깔 바뀌는 시간
navigation : 	//버튼 여러개일 경우 ?

OnClick		//클릭시 호출되는 함수


[AudioSource] 	//사운드 재생 컴포넌트
AudioClip : 		//사운드 파일 삽입
Play On Awake : 체크해제	//처음 시작시 한번 재생, 배경음악

assetstore - 효과음 




1. 계획하기
장르 : 생활 RPG
목표 : 생활 속에서 능력치를 발전시킴, 고대 유물 발견으로 마법 퀘스트 진입,  
구성 :   재료 : 나무, 돌, 식물, 동물,   
          도구 : 도끼, 곡괭이, 
          2차 가공 : 목재, 석재, 약초, 목축, 집, 밭, 농장
          스킬 :  근력 :   운동 : 2단점프 개방

구상도 : 




class Player
{
public float jumpPower;	//public시 초기값 필요없음
bool isJump;

Rigidbody r;

void Awake()
{
	isJump = false;	//false로 초기값
	rigid = GetComponent<Rigidbody>();
}

void FixedUpdate()
{
	move();
}

void Update()
{
	jump();
}

void Move()
{
	float h = Input.GetAxis("Horizontal")
	float v = Input.GetAxis("Vertical")
	float f  = Input.GetButtonDown("fly")
	r.AddForce(new Vector3(h, f, v), ForceMode.Impulse);
}

void Jump()
{
	if(Input.GetButtonDown("Jump") && !isJump)
	{ 
	isJump = true;
	r.AddForce(new Vector3(0, jumpPower, 0), ForceMode.Impulse);
	}
}

voidOnCollisionEnter(Collision c)
{
	if(c.gameObject.tag == "Floor")
	{
		isJump = false;
	}
}
}



[회전하는 몬스터 ]
class Monster


public float rotateSpeed;
public int itemCount;	//public 선언시 초기값 x


void Update()
{
	//transform.Rotate(Vector3.up * rotateSpeed * Time.deltaTime);		 // Rotate : 매개변수로 회전시키는 함수, 총 5개가 오버로드, 이 메서드 그대로 실행시 지역 좌표로 회전
	transform.Rotate(Vector3.up * rotateSpeed * Time.deltaTime, Space.World );  // Space.World 월드 좌표로 회전, Space.local : 지역 좌표 
}

void OnTriggerEnter(Collider c)
{
	if(c.name == "Player")	//플레이어와 충돌시
	{
	PlayerBall pb= c.GetComponent<PlayerBall>();
	pb.itemCount++;
	gameObject.SetActive(false); 	// SetActive(bool) : object 활성화/비활성화 함수, 비활성화시 scene창에서 투명화, 
	}
}


[플레이어 아이템 습득시 오디오 활성화]
Player - AudioSource Component 추가

class Player
{
AudioSource audio;

}

void Awake()	
{
	audio = GetComponene<AudioSource>();
}

void OnTriggerEnter(Collider c)
{
	if(c.tag == "Item")	//tag 이름과 충돌시
	{
	itemCount++;
	audio.Play();
	c.gameObject.SetActive(false);

	}
}



[플레이어를 따라다니는 카메라]
(준비 : 카메라에 FollowingCam skirpt 적용)

public class FollowingCam  
{

Transform playerT;		//플레이어 위치 가져오기
Vector3 offset;		//조정값

void Awake()
{
	playerT = GameObject.FindGameObjectWithTag("Player").transform;   //.FindGameObjectWithTag("") : 주어진 태그로 게임object 검색 - cpu 부하를 초래하므로 피하는 것이 좋다.
	offset = transform.position - playerT.position;
}

void LateUpdate()
{
	transform.position = playerT.position + offset;
}

}


[장면이동]

UnityEngine.SceneManagement;	//scene을 가져오기 위해, scene Example1_0, 1_1 등 추가한뒤 Build Setting - Scenes in Build - Add Open Scenes 눌러서 추가해야함

class Player	 //위에 Player skirpt 그대로 복사한후 추가해야함
{
public GameManagerLogic manager;   //inspector에서 GameManager object(GM skript가 있는) 끌어옴
}

void OnTriggerEnter(Collider c)	
{
	if(c.name == "Player")	
	{
	PlayerBall pb= c.GetComponent<PlayerBall>();
	pb.itemCount++;
	gameObject.SetActive(false);
	manager.GetItem(itemCount);	//GameManager - GetItem() 함수
	}
	else if (c.tag == "Finish")
	{
		if(itemCount = manager.tatalItemCount) 
		{
		//Game Clear 및 Next Stage
			if(manager.stage ==2)
			SceneManager.LoadScene(0);
			//SceneManager.LoadScene("Example1_0");
			else
			SceneManager.LoadScene(manager.stage + 1);
			//SceneManager.LoadScene("Example1_"+(manaer.stage+1).ToString());
		}
		else
		{
		//restart...
		SceneManager.LoadScene(manager.stage);
		//SceneManager.LoadScene("Example1_"+manaer.stage.ToString());
		}
	}
}




UnityEngine.SceneManagement;	//선언
UnityEngine.UI;	//선언

class GameManager
{
public int totalItemCount;   //GameManager object에 이 skript연결 후 inspector에 4라고 적음
public int stage;
public Text stageCountText; //GameManager object에 이 skript연결 후 canvas에서 해당 text 끌어와서 넣음
public Text playerCountText; //GameManager object에 이 skript연결 후 canvas에서 해당 text 끌어와서 넣음
}

void Awake()
{
stageCountText.text = "/" + totalItemCount.ToString();
}

public void GetItem(int count)
{
playerCountText.text = count.ToString();
}

void OnTriggerEnter(Collider c)  	//scene에서 빈object에 BoxCollider  x, y, z 를 100,1,100으로 설정한 뒤
{
	if(c.gameObject.tag == "Player")
	SceneManager.LoadScene(stage);	//skript에 stage기록

}


//UI - Image
1. Image 추가 : anchor 좌측에 맞추고, 여백 pos X, pos Y에 각 10, -10을 줌
3. Text 추가(player item Text) :  anchor 좌측에 맞추고, 여백 pos Y에 -10을 줌, 정렬 좌, 중으로 맞추고, pont 50, Text에 0기입 
3. Text 추가(stage item Text) :  anchor 좌측에 맞추고, 여백 pos Y에 -10을 줌, 정렬 좌, 중으로 맞추고, pont 50, Text에 /0기입 

4. 모든작업이 끝나면 Canvas 복사 후 모든 장면 scene에 전부 추가, 
GameManager object의 inspector에 stageCountText, playerCountText에 canvas에서 해당 text 끌어와서 넣음






